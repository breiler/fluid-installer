{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://installer.fluidnc.com/schema/fluidnc.schema.json",
    "title": "FluidNC config root",
    "description": "A schema for FluidNC config files",
    "type": "object",
    "$defs": {
      "axis": {
        "type": "object",
        "properties": {
          "steps_per_mm": {
            "type": "integer"
          },
          "max_rate_mm_per_min": {
            "type": "integer"
          },
          "acceleration_mm_per_sec2": {
            "type": "integer"
          },
          "max_travel_mm": {
            "type": "integer"
          },
          "homing": {
            "type": "object",
            "properties": {
              "cycle": {
                "type": "integer",
                "description": "Homing cycles determine each axis home. Cycles allow you to home axes one at a time or group a few axes into a single cycle for multi-axis homing. Assign the same number to multiple axes to home them in the same cycle. Many people would home the Z first (cycle: 1) and then might home X and Y at the same time (cycle: 2)\nA setting of 1 or greater enables the axis for homing with $H. Anything lower than 1 will be an inactive cycle and no physical homing will occur for that axis.\nA setting of 0 means it will not home with $H, but you can still home it with $H<axis>\nA value of -1 means the machine will not move, but the current machine position (mpos) position of the axis will be set to the mpos_mm value for the axis. This can be used for axes that don't have any switches.\nTypically you would put the Z axis on cycle: 1 and the other axes on higher cycles.",
                "enum": [
                  -1,
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6
                ]
              },
              "mpos_mm": {
                "type": "integer"
              },
              "positive_direction": {
                "type": "boolean"
              },
              "seek_mm_per_min": {
                "type": "integer"
              },
              "feed_mm_per_min": {
                "type": "integer"
              }
            }
          },
          "motor0": {
            "$ref": "#/$defs/motor"
          },
          "motor1": {
            "$ref": "#/$defs/motor"
          }
        }
      },
      "motor": {
        "type": "object",
        "properties": {
          "limit_neg_pin": {
            "type": "string",
            "default": "NO_PIN",
            "description": "Pin used to detect limit switch activation on the negative side of axis travel."
          },
          "limit_pos_pin": {
            "type": "string",
            "description": "Pin used to detect limit switch activation on the positive side of axis travel. This switch will often be just beyond the max_travel limit."
          },
          "limit_all_pin": {
            "type": "string",
            "default": "NO_PIN",
            "description": "Used when you want switches at both ends of travel wired to the same pin. If limit_all_pin is specified, do not specify a limit_neg_pin or a limit_pos_pin. A drawback to using this feature is that FluidNC does not know which end of travel is causing the trigger. It cannot determine which way to move to clear the switch. Because of this, switches must be cleared manually before homing."
          },
          "hard_limits": {
            "type": "boolean",
            "default": false,
            "description": "Set this to true when you want to use the switches defined above as hard limits. Hard limits immediately stop all motion when the switch is activated. Position is considered lost and rehoming is required."
          },
          "pulloff_mm": {
            "type": "integer",
            "default": 1,
            "description": "This is the distance to pull off a touched switch with this motor. This value should be greater than the amount you can travel after the switch is activated. This makes sure you can always clear the switch during homing."
          },
          "standard_stepper": {
            "type": "object",
            "properties": {
              "step_pin": {
                "type": "string",
                "description": "Some external drivers require an inverted step pulse. You can invert the pulse by changing the active state attribute (:high or :low)"
              },
              "direction_pin": {
                "type": "string",
                "description": "This is used to control the direction. You can invert the direction by changing the active state attribute (:high or :low)"
              },
              "disable_pin": {
                "type": "string",
                "description": "This is used if your controller uses individual disable pins for each driver. Most basic controllers use a common disable pin for all drivers and that is set elsewhere in the config file. You can invert the direction by changing the active state attribute (:high or :low)"
              }
            }
          }
        }
      },
      "uart": {
        "type": "object",
        "properties": {
          "txd_pin": {
            "type": "string"
          },
          "rxd_pin": {
            "type": "string"
          },
          "rts_pin": {
            "type": "string"
          },
          "baud": {
            "type": "integer"
          },
          "mode": {
            "type": "string"
          }
        },
        "required": [
          "baud",
          "mode",
          "rxd_pin",
          "txd_pin"
        ],
        "examples": [
          {
            "txd_pin": "gpio.0",
            "rxd_pin": "gpio.4",
            "rts_pin": "gpio.13",
            "baud": 115200,
            "mode": "8N1"
          }
        ]
      },
      "uart_channel": {
        "type": "object",
        "properties": {
          "report_interval_ms": {
            "type": "integer",
            "minimum": 50,
            "maximum": 5000,
            "description": "This sets the reporting interval during motion. It is generally used to update DROs. If you srt it to zero it will be off. Ideally it should be 0 or 50-5000 to prevent overloading the processor."
          },
          "uart_num": {
            "type": "integer",
            "description": "This connects it to a previously defined uart section."
          },
          "message_level": {
            "enum": [
              "none",
              "error",
              "warn",
              "info",
              "debug"
            ],
            "type": "string",
            "description": "his allows you to limit the messages that will be sent to this channel. It is useful for displays and pendants that do not need the messages and would rather not have to process them. Only messages at levels less than or equal to the chosen value will be sent to the channel. The global configuration value $Message/Level also applies, limiting messages to all channels. The channel-specific message_level item is an additional restriction, so only messages at levels at or below the lesser of $Message/Level or message_level will go to this channel."
          }
        }
      }
    },
    "properties": {
      "name": {
        "type": "string",
        "description": "A basic description of the machine such as \"Router XYYZ 10V Spindle\"",
        "maxLength": 80
      },
      "board": {
        "type": "string",
        "description": "Descriptive text such as \"ESP32 Dev Controller V4\".",
        "maxLength": 80
      },
      "meta": {
        "type": "string",
        "description": "This is used to store information about the config file such as \"B. Dring 2022-03-15 Rev 2\"",
        "maxLength": 80
      },
      "verbose_errors": {
        "type": "boolean",
        "description": "Prints an error string with each error code. This might not be compatible with some gcode senders."
      },
      "arc_tolerance_mm": {
        "type": "number",
        "description": "FluidNC converts arcs into tiny line segments representing the arc. This value determines how closely the segments represent the arc. This value is rarely changed by the user.",
        "minimum": 0.001,
        "maximum": 1
      },
      "junction_deviation_mm": {
        "type": "number",
        "description": "Junction deviation is used by the planner to calculate cornering speeds. This is generally not adjusted by the user. Read the firmware source code for a full description.",
        "minimum": 0.01,
        "maximum": 1
      },
      "report_inches": {
        "type": "boolean",
        "description": "Set to true for inches and false for millimeters. This is only for reporting and not input values."
      },
      "enable_parking_override_control": {
        "type": "boolean",
        "description": "This allows you to override the parking feature via gcode. When true M56 P0 disables parking and M56 P1 enables it."
      },
      "use_line_numbers": {
        "type": "boolean",
        "description": "Allow FluidNC to use line numbers in gcode. To use line numbers, set this to true. Put line numbers in the gcode with N<line number>, like N100. The line number that is currently being executed by the motion planner will be displayed in the status reports with Ln:100. If there is no line number information in the gcode, it will report Ln:0."
      },
      "planner_blocks": {
        "type": "number",
        "description": "This sets the number of blocks used in the planner. You should leave it at the default unless you are tuning for a special application.",
        "minimum": 10,
        "maximum": 120
      },
      "stepping": {
        "title": "Stepping",
        "type": "object",
        "properties": {
          "engine": {
            "type": "string",
            "description": "This determines the method used to generate the steps in firmware. Controller board hardware is designed for either RMT or I2S stepping so you must choose a method that your controller board hardware uses. It is not possible to mix and match stepping types on different motors.",
            "enum": [
              "RMT",
              "TIMED",
              "I2S_STATIC",
              "I2S_STREAM"
            ]
          },
          "idle_ms": {
            "type": "integer",
            "description": "A value of 255 will keep the motors enabled at all times (preferred for most projects). Any other value, either between 0-254 or from 256- 4294967295, will disable all the motors that many milliseconds after the last step on any motor. Note: Motors can be manually disabled at any time with the $MD command.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "dir_delay_us": {
            "type": "integer",
            "description": "The delay(microseconds) needed between a direction change and a step pulse. Many drivers do not need a delay here.",
            "minimum": 0,
            "maximum": 10
          },
          "pulse_us": {
            "type": "integer",
            "description": "The duration of the step pulses (microseconds). This is the \"on\" duration of the pulse. It typically needs an equal \"off\" duration. This means the max number of steps per second will be 1,000,000/(pulse_us*2). Stepper drivers will have a minimum required time length for pulses to register them. If the manufacturer provides a datasheet for the stepper driver, this value can be found",
            "minimum": 0,
            "maximum": 10
          },
          "disable_delay_us": {
            "type": "integer",
            "description": "Some motors need a delay from when they are enabled to when they can take the first step. This value is the number of microsecond delayed.",
            "minimum": 0,
            "maximum": 10
          },
          "segments": {
            "type": "number",
            "description": "This sets the number of segment buffers. You should leave this at the default unless you are trying to fine tune a special application.",
            "minimum": 6,
            "maximum": 20
          }
        },
        "required": []
      },
      "axes": {
        "type": "object",
        "properties": {
          "shared_stepper_disable_pin": {
            "type": "string"
          },
          "homing_runs": {
            "type": "integer"
          },
          "x": {
            "$ref": "#/$defs/axis"
          },
          "y": {
            "$ref": "#/$defs/axis"
          },
          "z": {
            "$ref": "#/$defs/axis"
          },
          "a": {
            "$ref": "#/$defs/axis"
          },
          "b": {
            "$ref": "#/$defs/axis"
          },
          "c": {
            "$ref": "#/$defs/axis"
          }
        }
      },
      "parking": {
        "title": "Parking",
        "type": "object",
        "description": "",
        "properties": {
          "enable": {
            "type": "boolean"
          },
          "axis": {
            "type": "string"
          },
          "pullout_distance_mm": {
            "type": "integer"
          },
          "pullout_rate_mm_per_min": {
            "type": "integer"
          },
          "target_mpos_mm": {
            "type": "integer"
          },
          "rate_mm_per_min": {
            "type": "integer"
          }
        },
        "required": [
          "axis",
          "enable",
          "pullout_distance_mm",
          "pullout_rate_mm_per_min",
          "rate_mm_per_min",
          "target_mpos_mm"
        ]
      },
      "start": {
        "type": "object",
        "description": "This group controls optional things that happen at startup.",
        "properties": {
          "must_home": {
            "type": "boolean",
            "description": "This controls whether you are required to home at startup or not. You will get a homing alarm at startup if this value is true. This prevents motion until you home the machine or clear the alarm.",
            "default": true
          },
          "deactivate_parking": {
            "type": "boolean",
            "description": "Turns off the parking feature.",
            "default": true
          },
          "check_limits": {
            "type": "boolean",
            "description": "If true this will report if any limit switches are active at startup if hard_limits are true for the axis.",
            "default": false
          }
        }
      },
      "uart1": {
        "$ref": "#/$defs/uart"
      },
      "uart2": {
        "$ref": "#/$defs/uart"
      },
      "uart_channel1": {
        "$ref": "#/$defs/uart_channel"
      },
      "uart_channel2": {
        "$ref": "#/$defs/uart_channel"
      }
    }
  }